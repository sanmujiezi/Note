{
	"nodes":[
		{"id":"1a389b398cce9a49","type":"group","x":240,"y":360,"width":2800,"height":1440,"label":"提升"},
		{"id":"5c31529e7b4040dc","type":"group","x":240,"y":-840,"width":2800,"height":1080,"label":"基础"},
		{"id":"d28d05fca02f7d5d","type":"group","x":1360,"y":-660,"width":1586,"height":820,"label":"File"},
		{"id":"84c884c6e8395a4e","type":"group","x":320,"y":500,"width":840,"height":1160,"color":"4","label":"类的序列化"},
		{"id":"584721def8cc4859","type":"group","x":1200,"y":500,"width":840,"height":1160,"color":"4","label":"类的反序列化"},
		{"id":"0e975d0db418e17f","type":"group","x":320,"y":-660,"width":1000,"height":820,"label":"二进制"},
		{"id":"0062b0d5131ce19a","type":"group","x":2120,"y":920,"width":826,"height":740,"color":"4","label":"加密解密"},
		{"id":"2ee1832291663ad0","type":"group","x":629,"y":-579,"width":654,"height":656,"color":"4","label":"转换"},
		{"id":"794bf817e4f5b4c9","type":"text","text":"#### 非字符串类等\n`byte[] bytes = BitConverter.GetBytes(8);`\n回转\n`int nums = BItConverter.ToInt32(bytes);`","x":664,"y":-531,"width":597,"height":263},
		{"id":"b4350656ddae7d0e","type":"text","text":"特点：\n相较于其他的存储方式，它更加的节省内存并且安全","x":365,"y":-611,"width":229,"height":206,"color":"2"},
		{"id":"a5ab4d25e6002828","type":"text","text":"必要概念：\n1bit（位）中存储了一个二进制数\n1byte（字节）等于8bit\n","x":365,"y":-378,"width":229,"height":206,"color":"3"},
		{"id":"b7ad5aca49485caf","type":"text","text":"#### 字符串类\n通过指定的编码格式转为字节\n`byte[] bytes = Encoding.UTF8.GetBytes(\"汤圆\");`\n回转\n`string s  = Encoding.UTF8.GetString(bytes2);`\n\n","x":664,"y":-221,"width":597,"height":261},
		{"id":"e51a2206cd8f1a10","type":"text","text":"查看类的字节占用长度：\n`sizeof(类)`","x":365,"y":-144,"width":229,"height":206,"color":"5"},
		{"id":"9f0487e8041f4e1f","type":"file","file":"Content/文件IO.md","x":1404,"y":-620,"width":837,"height":400},
		{"id":"fbcf9ab24aafadfd","type":"text","text":"### 判断文件\n\n![[Pasted image 20241106230832.png]]\n### 创建文件\n![[Pasted image 20241106230851.png]]","x":2263,"y":-620,"width":661,"height":260,"color":"4"},
		{"id":"89766548b0327dd0","type":"text","text":"### 将字节写入路径的文件中\n```\n//写入字节\nbyte[] bytes = BitConverter.GetBytes(99);  \nFile.WriteAllBytes(Application.dataPath + \"/Tangyuan.tang\", bytes);  \n//分行写入string\nstring[] strs = new string[] { \"你好\", \"我叫\", \"汤圆\" };  \nFile.WriteAllLines( Application.dataPath + \"/Tangyuan1.tang\", strs);  \n//写入任意字符串\nFile.WriteAllText(Application.dataPath + \"/Tangyuan2.tang\",\"你好啊！！\");\n```\n","x":1404,"y":-200,"width":837,"height":288,"color":"4"},
		{"id":"34565fc010cba9bf","type":"text","text":"### 读取\n通过读取文件来将字节转换成相应的类型\n```\n//读取字节\nbyte[] bytes = File.ReadAllBytes(Appliction.datapath + \"地址\");\nprint(Bitconver.ToInt32(bytes,0))\n\n//读取所有行信息\nstring[] strs = File.ReadAllLine(Appliction.datapath + \"地址\");\n\n//读取文本\nFilie.ReadAllText(Appliction.datapath + \"地址\");\n\n```\n","x":2263,"y":-344,"width":661,"height":432,"color":"4"},
		{"id":"c949f1358aca64e1","type":"text","text":"### 使用文件流对类序列化  \n```\n//使用文件流对类序列化  \npath = Application.dataPath + \"/Tangyuan1.tang\";  \ns = new Student();  \nusing (FileStream fileStream = new FileStream(path,FileMode.Create))  \n{  \n    BinaryFormatter binaryFormatter = new BinaryFormatter();  \n    binaryFormatter.Serialize(fileStream,s);  \n    fileStream.Flush();  \n    fileStream.Close();  \n}\n```","x":347,"y":1100,"width":786,"height":480},
		{"id":"98c56dda4a8a1ea2","type":"text","text":"### 使用内存流反序列化  \n```\n//内存流读取  \npath = Application.dataPath + \"/Tangyuan.tang\";  \nbyte[] bytes = File.ReadAllBytes(path);  \n  \nusing (MemoryStream ms = new MemoryStream(bytes))  \n{  \n    BinaryFormatter bf = new BinaryFormatter();  \n    Student s1 = bf.Deserialize(ms) as Student;  \n    Debug.Log(s1.name);  \n    ms.Close();  \n  \n}\n```","x":1227,"y":600,"width":786,"height":480},
		{"id":"40c0ab6d0eff08f3","type":"text","text":"### 使用文件流对类反序列化  \n```\nstring path = Application.dataPath + \"/Tangyuan1.tang\";  \n//文件流读取  \nusing (FileStream fs = new FileStream(path, FileMode.Open, FileAccess.Read))  \n{  \n    BinaryFormatter bf = new BinaryFormatter();  \n    Student s1 = bf.Deserialize(fs) as Student;  \n    Debug.Log(s1.name);  \n    fs.Close();  \n}\n```","x":1227,"y":1100,"width":786,"height":480},
		{"id":"5363bcf2cc8875ff","type":"text","text":"### 内存流序列化\n\n优点：可以在内存种暂存\n方便在内存种做更多处理\n例如：\n网络传输处理\n\n> [!tip] ToArray对比GetBuffer\n> ToArray将复制缓冲区是的数组，不带有引用关系\n> GetBuffer是直接返回数据，带有引用关系\n","x":2121,"y":527,"width":825,"height":333,"color":"2"},
		{"id":"623a476afadcecac","type":"text","text":"### 使用内存流序列化  \n```\n//使用内存流对类序列化  \nstring path = Application.dataPath + \"/Tangyuan.tang\";  \n  \nStudent s = new Student();  \nusing (MemoryStream memoryStream = new MemoryStream())  \n{  \n    BinaryFormatter binaryFormatter = new BinaryFormatter();  \n    binaryFormatter.Serialize(memoryStream,s);  \n    byte[] bytes = memoryStream.GetBuffer();  \n    File.WriteAllBytes(path, bytes);  \n      \n    memoryStream.Close();  \n}\n```","x":347,"y":560,"width":786,"height":480},
		{"id":"047c638223ca892b","type":"text","text":"### 使用内存流二进制加密\n```\npath = Application.dataPath + \"/Tang.yuan\";  \nStudent s = new Student();  \n  \nusing (MemoryStream ms = new MemoryStream())  \n{  \n    BinaryFormatter bf = new BinaryFormatter();  \n    bf.Serialize(ms, s);  \n    byte[] bytes = ms.ToArray();  \n    //通过异或算法加密\n    for (int i = 0; i < bytes.Length; i++)  \n    {  \n        bytes[i] ^= key;  \n    }  \n  \n    File.WriteAllBytes(path, bytes);  \n    ms.Close();  \n}\n```","x":2174,"y":960,"width":720,"height":300},
		{"id":"b317152131a62c5a","type":"text","text":"### 使用内存流二进制解密\n```\nbyte[] _bytes = File.ReadAllBytes(path);  \nfor (int i = 0; i < _bytes.Length; i++)  \n{  \n    _bytes[i] ^= key;  \n}  \nusing (MemoryStream ms = new MemoryStream(_bytes))  \n{  \n    BinaryFormatter bf = new BinaryFormatter();  \n    Student _s =  bf.Deserialize(ms) as Student;  \n    ms.Close();  \n}\n```","x":2174,"y":1290,"width":720,"height":290}
	],
	"edges":[]
}