{
	"nodes":[
		{"id":"48020c6d0fa1ad42","type":"group","x":240,"y":1880,"width":2800,"height":1680,"label":"Excel"},
		{"id":"1a389b398cce9a49","type":"group","x":240,"y":360,"width":2800,"height":1440,"label":"提升"},
		{"id":"59db6cf2d6e628fc","type":"group","x":1440,"y":1960,"width":1506,"height":1200,"label":"Excel转二进制插件"},
		{"id":"84c884c6e8395a4e","type":"group","x":320,"y":500,"width":840,"height":1160,"color":"4","label":"类的序列化"},
		{"id":"584721def8cc4859","type":"group","x":1200,"y":500,"width":840,"height":1160,"color":"4","label":"类的反序列化"},
		{"id":"0062b0d5131ce19a","type":"group","x":2120,"y":920,"width":826,"height":740,"color":"4","label":"加密解密"},
		{"id":"5c31529e7b4040dc","type":"group","x":240,"y":-840,"width":2800,"height":1080,"label":"基础"},
		{"id":"d28d05fca02f7d5d","type":"group","x":1360,"y":-660,"width":1586,"height":820,"label":"File"},
		{"id":"0e975d0db418e17f","type":"group","x":320,"y":-660,"width":1000,"height":820,"label":"二进制"},
		{"id":"2ee1832291663ad0","type":"group","x":629,"y":-579,"width":654,"height":656,"color":"4","label":"转换"},
		{"id":"794bf817e4f5b4c9","type":"text","text":"#### 非字符串类等\n`byte[] bytes = BitConverter.GetBytes(8);`\n回转\n`int nums = BItConverter.ToInt32(bytes);`","x":664,"y":-531,"width":597,"height":263},
		{"id":"b7ad5aca49485caf","type":"text","text":"#### 字符串类\n通过指定的编码格式转为字节\n`byte[] bytes = Encoding.UTF8.GetBytes(\"汤圆\");`\n回转\n`string s  = Encoding.UTF8.GetString(bytes2);`\n\n","x":664,"y":-221,"width":597,"height":261},
		{"id":"e51a2206cd8f1a10","type":"text","text":"查看类的字节占用长度：\n`sizeof(类)`","x":365,"y":-144,"width":229,"height":206,"color":"5"},
		{"id":"a5ab4d25e6002828","type":"text","text":"必要概念：\n1bit（位）中存储了一个二进制数\n1byte（字节）等于8bit\n","x":365,"y":-378,"width":229,"height":206,"color":"3"},
		{"id":"b4350656ddae7d0e","type":"text","text":"特点：\n相较于其他的存储方式，它更加的节省内存并且安全","x":365,"y":-611,"width":229,"height":206,"color":"2"},
		{"id":"9f0487e8041f4e1f","type":"file","file":"Content/文件IO.md","x":1404,"y":-620,"width":837,"height":400},
		{"id":"89766548b0327dd0","type":"text","text":"### 将字节写入路径的文件中\n```\n//写入字节\nbyte[] bytes = BitConverter.GetBytes(99);  \nFile.WriteAllBytes(Application.dataPath + \"/Tangyuan.tang\", bytes);  \n//分行写入string\nstring[] strs = new string[] { \"你好\", \"我叫\", \"汤圆\" };  \nFile.WriteAllLines( Application.dataPath + \"/Tangyuan1.tang\", strs);  \n//写入任意字符串\nFile.WriteAllText(Application.dataPath + \"/Tangyuan2.tang\",\"你好啊！！\");\n```\n","x":1404,"y":-200,"width":837,"height":288,"color":"4"},
		{"id":"5363bcf2cc8875ff","type":"text","text":"### 内存流序列化\n\n优点：可以在内存种暂存\n方便在内存种做更多处理\n例如：\n网络传输处理\n\n> [!tip] ToArray对比GetBuffer\n> ToArray将复制缓冲区是的数组，不带有引用关系\n> GetBuffer是直接返回数据，带有引用关系\n","x":2121,"y":527,"width":825,"height":333,"color":"2"},
		{"id":"fbcf9ab24aafadfd","type":"text","text":"### 判断文件\n\n![[Pasted image 20241106230832.png]]\n### 创建文件\n![[Pasted image 20241106230851.png]]","x":2263,"y":-620,"width":661,"height":260,"color":"4"},
		{"id":"34565fc010cba9bf","type":"text","text":"### 读取\n通过读取文件来将字节转换成相应的类型\n```\n//读取字节\nbyte[] bytes = File.ReadAllBytes(Appliction.datapath + \"地址\");\nprint(Bitconver.ToInt32(bytes,0))\n\n//读取所有行信息\nstring[] strs = File.ReadAllLine(Appliction.datapath + \"地址\");\n\n//读取文本\nFilie.ReadAllText(Appliction.datapath + \"地址\");\n\n```\n","x":2263,"y":-344,"width":661,"height":432,"color":"4"},
		{"id":"a9ed7507551def99","type":"text","text":"IExcelDataReader是一个读取器的接口，在ExcelReaderFactory工厂中创建的读取器通过这个接口来做返回值。\n\nDataSet是.net中用来接收工作表的类，它里面能够存放多个表。\n\nDataTable存储单个数据表\nDataRow存储表中的单行\n通过Row的索引器来获取\n\n","x":850,"y":1960,"width":570,"height":260,"color":"2"},
		{"id":"0de2d2f271367979","type":"text","text":"### Eexcel库\n库为dll程序集\n![[Pasted image 20241109160230.png]]\n下载后通常放在untiy的Editor文件中\n\n调用这两个库的主脚本，也需要放在这个文件夹中才能够生效","x":280,"y":1960,"width":540,"height":260,"color":"3"},
		{"id":"0660fc695418fea5","type":"text","text":"### 调用Excel\n```\nusing (FileStream fs = new FileStream(path, FileMode.Open, FileAccess.Read))  \n{  \n   IExcelDataReader reader = ExcelReaderFactory.CreateOpenXmlReader(fs);  \nDataSet result = reader.AsDataSet();  \nif (result.Tables.Count < 0)  \n{  \n    Debug.LogError(\"表不存在\");  \n    return;  \n}  \n  \nfor (int i = 0; i < result.Tables.Count; i++)  \n{  \n    DataTable table = result.Tables[i];  \n    Debug.Log(\"表名:\" + table.TableName);  \n    for (int k = 0; k < table.Rows.Count; k++)  \n    {  \n        DataRow row = table.Rows[k];  \n        Debug.Log(\"行数:\" + k);  \n        for (int j = 0; j < table.Columns.Count; j++)  \n        {  \n            Debug.Log(row[j].ToString());   \n        }  \n    }  \n}\n}\n```","x":280,"y":2240,"width":1140,"height":720,"color":"4"},
		{"id":"6ad079da396cf5aa","type":"text","text":"### 生成数据类与容器类\n\n类文件其本质就是由字符串构成的，所以只需要使用字符串拼接即可","x":1480,"y":2000,"width":280,"height":180,"color":"4"},
		{"id":"9bff10013caa6649","type":"text","text":"### 生成数据类\n类文件其本质就是由字符串构成的，所以只需要使用字符串拼接即可","x":1480,"y":2220,"width":280,"height":180,"color":"4"},
		{"id":"96a582c06d463ec1","type":"file","file":"Image/Excel转二进制知识点.png","x":1780,"y":2000,"width":879,"height":400},
		{"id":"afa80d592972b7e2","type":"text","text":"### 补充知识点\n在使用File类的Writ写入字符串的字节码时，需要以下三个步骤：\n- **获取字节长度**\n- **写入字节长度**\n- **写入字符串字节**","x":2680,"y":2000,"width":220,"height":400,"color":"2"},
		{"id":"b317152131a62c5a","type":"text","text":"### 使用内存流二进制解密\n```\nbyte[] _bytes = File.ReadAllBytes(path);  \nfor (int i = 0; i < _bytes.Length; i++)  \n{  \n    _bytes[i] ^= key;  \n}  \nusing (MemoryStream ms = new MemoryStream(_bytes))  \n{  \n    BinaryFormatter bf = new BinaryFormatter();  \n    Student _s =  bf.Deserialize(ms) as Student;  \n    ms.Close();  \n}\n```","x":2174,"y":1290,"width":720,"height":290},
		{"id":"40c0ab6d0eff08f3","type":"text","text":"### 使用文件流对类反序列化  \n```\nstring path = Application.dataPath + \"/Tangyuan1.tang\";  \n//文件流读取  \nusing (FileStream fs = new FileStream(path, FileMode.Open, FileAccess.Read))  \n{  \n    BinaryFormatter bf = new BinaryFormatter();  \n    Student s1 = bf.Deserialize(fs) as Student;  \n    Debug.Log(s1.name);  \n    fs.Close();  \n}\n```","x":1227,"y":1110,"width":786,"height":480},
		{"id":"c949f1358aca64e1","type":"text","text":"### 使用文件流对类序列化  \n```\n//使用文件流对类序列化  \npath = Application.dataPath + \"/Tangyuan1.tang\";  \ns = new Student();  \nusing (FileStream fileStream = new FileStream(path,FileMode.Create))  \n{  \n    BinaryFormatter binaryFormatter = new BinaryFormatter();  \n    binaryFormatter.Serialize(fileStream,s);  \n    fileStream.Flush();  \n    fileStream.Close();  \n}\n```","x":347,"y":1110,"width":786,"height":480},
		{"id":"a6f5dcad0a40e357","type":"file","file":"Image/表格数据转换器.png","x":1480,"y":2440,"width":578,"height":480},
		{"id":"db6861680557e353","x":2083,"y":2440,"width":817,"height":680,"color":"1","type":"text","text":"### 架构记录\n\n转换流程举例：\n- 用户通过界面选择好输入路径与输出路径\n- 用户通过选择转换的目标格式\n- 用户点击开始转换\n- controller读取到数据\n- 执行转换函数\n- 判断输入输出路径有效性\n- 判断格式有效性\n- 选择对应的转换策略\n- 读取excle的首行，并输出数据模型model\n- 读取第2行与第4行，并用字典记录数据\n- 循环遍历这两行，记录整行数据到字典中\n- 依次遍历所有行，然后将所有行的数据记录到最外层的字典中\n\t字典结构 dic<int,dic<string,object>>\n- 然后返回出这个字典，并传送给转换器\n- 转换器将得到的字典转换为对应的格式内容\n"},
		{"id":"98c56dda4a8a1ea2","type":"text","text":"### 使用内存流反序列化  \n```\n//内存流读取  \npath = Application.dataPath + \"/Tangyuan.tang\";  \nbyte[] bytes = File.ReadAllBytes(path);  \n  \nusing (MemoryStream ms = new MemoryStream(bytes))  \n{  \n    BinaryFormatter bf = new BinaryFormatter();  \n    Student s1 = bf.Deserialize(ms) as Student;  \n    Debug.Log(s1.name);  \n    ms.Close();  \n  \n}\n```","x":1227,"y":600,"width":786,"height":480},
		{"id":"623a476afadcecac","type":"text","text":"### 使用内存流序列化  \n```\n//使用内存流对类序列化  \nstring path = Application.dataPath + \"/Tangyuan.tang\";  \n  \nStudent s = new Student();  \nusing (MemoryStream memoryStream = new MemoryStream())  \n{  \n    BinaryFormatter binaryFormatter = new BinaryFormatter();  \n    binaryFormatter.Serialize(memoryStream,s);  \n    byte[] bytes = memoryStream.GetBuffer();  \n    File.WriteAllBytes(path, bytes);  \n      \n    memoryStream.Close();  \n}\n```","x":347,"y":560,"width":786,"height":480},
		{"id":"047c638223ca892b","type":"text","text":"### 使用内存流二进制加密\n```\npath = Application.dataPath + \"/Tang.yuan\";  \nStudent s = new Student();  \n  \nusing (MemoryStream ms = new MemoryStream())  \n{  \n    BinaryFormatter bf = new BinaryFormatter();  \n    bf.Serialize(ms, s);  \n    byte[] bytes = ms.ToArray();  \n    //通过异或算法加密\n    for (int i = 0; i < bytes.Length; i++)  \n    {  \n        bytes[i] ^= key;  \n    }  \n  \n    File.WriteAllBytes(path, bytes);  \n    ms.Close();  \n}\n```","x":2174,"y":960,"width":720,"height":300}
	],
	"edges":[]
}