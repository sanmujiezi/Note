# 任务安排
- [ ] 使用媒体软件之前默念10遍打开的目的 🔁 
- [x] 保持专注，所有需要高度专注的工作都是用番茄钟工作法 🔁 ✅ 2025-03-17
- [ ] 列出三分化计划，下肢、上肢、核心 ⏫ 
- [ ] 列出一周吃饭的安排 🔼 
- [ ] 详细列出解耦代码步骤 ⏫ 
- [ ] 看完游戏设计中的空间章节 🔺 
- [ ] 根据空间章节总结一个小文章，发自媒体 🔼 
- [ ] 跑步 5公里 公园一圈+到smart青年城来回 ⏫ 
- [ ] 普通俯卧撑20 x2 🔼 
- [ ] 窄距俯卧撑退阶10 🔼 
- [ ] 窄距俯卧撑10 🔼 

# 代码解耦
## 主要逻辑
1. 通过分层来确定我们要怎么去把大的功能拆解成模块
2. 需要考虑到我们主要使用方式的特性来决定，如果不确认就先按照直觉做，有问题再调整。
3. 然后再考虑模块之间的通信方式
4. 其中要尽量考虑到单一职责化和避免类与类的直接依赖[^1]
5. 再处理模块与模块之间的通信时可以使用工具类，比如一个公用的符合流程的事件类。
6. 还可以更具自己的流程需求拆分出更多模块，只要保证他们的使用流程与时序正确，并且是单一职责的模块就行。


## 示例1 自定义结构
### **1. 核心模块**

| 模块名                       | 职责                                         |
| ------------------------- | ------------------------------------------ |
| **PrefabTemplateLoader**  | 负责加载预制件模板（从指定路径或默认配置）。                     |
| **ImageLoader**           | 从文件夹加载图片资源（支持批量加载、格式过滤、异步加载）。              |
| **PrefabInstanceBuilder** | 基于模板实例化新预制件，并替换目标组件的图片（如`SpriteRenderer`）。 |
| **PrefabSaver**           | 处理预制件的保存逻辑（覆盖原文件或新建文件）。                    |

---

### **2. 用户界面层 (ImGUI)**

|模块名|职责|
|---|---|
|**UIMainPanel**|主界面布局：显示模板路径、图片文件夹路径、操作按钮。|
|**UIPreviewSection**|预览加载的模板和图片（可选缩略图）。|
|**UIErrorHandler**|显示错误提示（如路径无效、图片加载失败）。|

---

### **3. 数据层**

|模块名|职责|
|---|---|
|**ToolConfig**|存储工具配置（如默认模板路径、图片文件夹路径、保存路径规则）。|
|**PrefabData**|定义预制件的关键数据（如需要替换的组件类型、目标属性名）。|

---

### **4. 工具层**

| 模块名                    | 职责                                                   |
| ---------------------- | ---------------------------------------------------- |
| **PathValidator**      | 验证路径合法性（检查文件是否存在、是否为预制件/图片文件夹）。                      |
| **DependencyResolver** | 解析预制件的依赖关系（如确保替换的图片类型匹配目标组件）。                        |
| **EventBus**           | 事件总线，用于模块间通信（如`OnTemplateLoaded`、`OnImageReplaced`）。 |
|                        |                                                      |
#### **扩展性设计**

- **支持多组件替换**：在`PrefabData`中定义多个目标组件和属性。
    
- **异步加载优化**：在`ImageLoader`中实现协程异步加载。
    
- **撤销/重做功能**：通过`Command Pattern`记录操作历史。
    
- **批量生成**：遍历图片文件夹，为每张图生成一个预制件。


## 示例2 MVC结构

### **MVC 结构设计**

#### **1. Model（数据与逻辑层）**

**职责**：管理数据、处理核心逻辑（如加载资源、修改预制件）。  
**关键模块**：

- **PrefabTemplateModel**
    
    - 管理预制件模板的加载和缓存。
        
    - 提供接口获取模板的组件引用（如需要替换的 `SpriteRenderer`）。
        
- **ImageLibraryModel**
    
    - 负责加载和管理图片文件夹中的图片资源。
        
    - 提供按名称或索引获取图片的方法。
        
- **PrefabBuilderModel**
    
    - 实现预制件的实例化、图片替换和保存逻辑。
        
    - 依赖 `PrefabTemplateModel` 和 `ImageLibraryModel`。
        
- **ToolConfigModel**
    
    - 通过 `ScriptableObject` 存储工具配置（如默认路径、保存规则）。
        

#### **2. View（界面层）**

**职责**：通过 ImGUI 绘制界面，接收用户输入，但不处理业务逻辑。  
**关键模块**：

- **TemplateSelectionView**
    
    - 显示模板路径输入框和“加载模板”按钮。
        
    - 预览加载的模板（如显示缩略图）。
        
- **ImageLibraryView**
    
    - 显示图片文件夹路径和图片列表（缩略图网格）。
        
    - 允许用户选择单张或多张图片。
        
- **GenerationControlsView**
    
    - 提供“生成预制件”按钮和保存路径输入。
        
- **ErrorPopupView**
    
    - 显示错误提示（如路径无效、图片加载失败）。
        

#### **3. Controller（控制层）**

**职责**：协调 Model 和 View，处理用户输入事件，调用业务逻辑。  
**关键模块**：

- **TemplateController**
    
    - 监听 `TemplateSelectionView` 的“加载模板”事件。
        
    - 调用 `PrefabTemplateModel` 加载模板，更新 `View` 的预览。
        
- **ImageLibraryController**
    
    - 监听 `ImageLibraryView` 的路径修改或图片选择事件。
        
    - 调用 `ImageLibraryModel` 加载图片，更新缩略图显示。
        
- **GenerationController**
    
    - 监听 `GenerationControlsView` 的“生成”按钮事件。
        
    - 调用 `PrefabBuilderModel` 生成并保存预制件。
        
- **ErrorHandlerController**
    
    - 监听 Model 层的错误事件，触发 `ErrorPopupView` 显示错误信息。

### 示例3 MVVM结构
### MVVM 实现方案**

针对你的需求（通过模板和图片生成新预制件并替换图片），以下是 MVVM 的分层设计：

####  分层结构**

| 层级            | 模块名                      | 职责                                                            | 示例实现                                                        |
| ------------- | ------------------------ | ------------------------------------------------------------- | ----------------------------------------------------------- |
| **Model**     | `PrefabTemplateModel`    | 加载预制件模板，解析其组件（如 `SpriteRenderer`）                             | 使用 `PrefabUtility.LoadPrefabContents` 加载模板，缓存关键组件引用。        |
|               | `ImageLibraryModel`      | 从文件夹加载图片资源，管理图片列表（支持格式过滤、异步加载）                                | 通过 `Texture2D.LoadImage` 加载图片，并触发事件通知 ViewModel。            |
| **View**      | `PrefabToolView`         | 通过 ImGUI 绘制界面：模板路径输入、图片预览、生成按钮                                | 使用 `GUI.TextField` 输入路径，`GUI.Button` 触发操作，`GUI.Label` 显示预览。 |
| **ViewModel** | `PrefabBuilderViewModel` | 协调 Model 和 View：  <br>- 监听 Model 的数据变更（如模板加载完成）  <br>- 处理生成逻辑 | 接收 `ImageLibraryModel` 的图片列表，调用替换方法，触发保存操作。                 |

#### **MVVM 与 MVC 的核心区别**

##### **1. 组件职责** 368

|架构|组件|职责|
|---|---|---|
|**MVC**|Controller|直接控制 View 和 Model，处理用户输入和业务逻辑流转（如调用 `Model.Load()` 后更新 View）。|
|**MVVM**|ViewModel|作为 View 的抽象，通过数据绑定同步 View 和 Model，封装界面逻辑（如数据格式化、验证）。|

##### **2. 数据交互方式** 47

- **MVC**：
    
    - View 可以直接访问 Model（如 `View.Display(Model.Data)`），导致耦合度高。
        
    - Controller 手动更新 View（如通过 `View.Update()` 方法）。
        
- **MVVM**：
    
    - View 和 Model **完全隔离**，仅通过 ViewModel 的绑定属性交互。
        
    - **双向数据绑定**：Model 数据变更自动更新 View，View 输入变更自动更新 Model（如输入框内容实时同步到数据）。
        

##### **3. 适用场景** 69

|架构|适用场景|
|---|---|
|**MVC**|中大型项目，需明确分层但无需复杂 UI 交互（如后台管理系统）。|
|**MVVM**|复杂 UI 应用（如数据驱动的工具、游戏编辑器），需频繁同步数据和视图（如实时预览功能）。|

##### **4. 优缺点对比** 110

|架构|优点|缺点|
|---|---|---|
|**MVC**|结构简单，适合快速开发；职责分离清晰。|View 和 Model 耦合度高；需手动操作 DOM/UI 元素。|
|**MVVM**|自动化同步数据与视图；更易维护和测试；适合复杂交互。|实现复杂度高（需依赖数据绑定框架）；小型项目可能过度设计。|

---

#### Unity 中实现 MVVM 的注意事项

1. **手动绑定替代方案**：  
    Unity 无原生数据绑定支持，可通过以下方式模拟：
    
    - **事件驱动**：使用 `UnityEvent` 或自定义事件通知 View 更新。
        
    - **属性监听**：在 ViewModel 中实现 `INotifyPropertyChanged` 接口。
        
2. **性能优化**：
    
    - 避免频繁触发绑定事件（如每帧更新），可通过阈值或脏标记控制更新频率。
        
    - 对图片加载等耗时操作使用协程或异步任务。
        
3. **与 Editor API 结合**：
    
    - 使用 `PrefabUtility` 和 `AssetDatabase` 接口时，需在主线程调用，避免异步冲突。
        

---

#### **总结**

- **MVVM 更适合你的需求**：若工具需要实时预览图片替换效果、支持批量生成等复杂交互，MVVM 的双向绑定和 ViewModel 的抽象能显著降低耦合度47。
    
- **MVC 更轻量**：若工具功能简单，无需频繁数据同步，MVC 的控制器直接操作模式可能更高效8。

[^1]: 类与类之间如果他们的方法中需要传入另一个类，那就是有依赖了，要避免
