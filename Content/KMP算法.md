
# what
KMP算法是三个国外小老头发明的，用于快速匹配字符串
# why
普通的暴力匹配算法会浪费大量的cpu能效和时间，它会对比依次对比主串与字串，如果字串内有字符和主串对应的位置不匹配就需要回退主串指针，而子串的长度是未知的，也就是说如果运气不好每次都在字串的最后一个字符哪里匹配不成功，那就会是O（M x N）的时间复杂度，为了更加高效的处理字符串的匹配所以诞生了KMP算法，它主要解决了主串指针的回退问题，将时间复杂度降低到了O(N+M)。
# where
在任何处理字符匹配的地方都可以使用到这个算法

# how
现在我是那三个小老头中的其中一人，带入他们思考一下怎么才能解决暴力匹配的低效呢？
低效的原因主要在于每次遇到不匹配的就直接回退到头然后在基础上index+1。
这真的有必要嘛？
这样直接回退主要是为了避免重复字符的匹配遗漏问题。
那我们只要解决了重复字符的匹配遗漏就能够拥有更高的效率了。
找准了这个问题之后，我们就能够有清晰的思路了，这也是NEXT数组的由来，它本质上就是对目标串重复字符的标记，当我们在匹配失败需要回退时，不需要主串移动指针，只需要通过NEXT数组找到对应位置的索引，然后将字串指针的索引放到这个位置，就能够实现毫不遗漏的匹配。

NEXT数组的生成逻辑：
生成数组时，我们要遍历目标字符串，从0索引开始，依次查找这个索引前的首位重复字符有哪些，当然在看前面重复有哪些的时候是不包括当前索引的字符串的。
重复元素的判定是指最左侧连续的数组与左侧的连续字符进行比较。
例如：
下表中我们要求目标串的NEXT数组，就需要从index0开始。
1. 0前面没有任何字符所以为-1
2. 1前面只有一个字符没有重复为0
3. 2前面只有两个字符不存在重复为0
4. 3前面有三个数字，重复为1
索引地图记录完毕，面扑完成啦！！！

接下来就可以按照暴力解算的方法去匹配了
1. 创建两个索引指针
2. 主指针按照循序匹配不会退
3. 目标指针在不匹配时，通过查找同位置的next数组索引将指针跳转到对应位置。
4. 直到全部匹配正确，或者主串剩余的字符位置小于目标串剩余的字符位置，才算结束。

|        | ⬇   |     |     |     |     |     |     |     |     |
| ------ | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| index  | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   |     |
| 主串     | A   | B   | C   | A   | B   | A   | B   | C   |     |
|        | ⬇   |     |     |     |     |     |     |     |     |
| index  | 0   | 1   | 2   | 3   |     |     |     |     |     |
| 目标串    | A   | B   | A   | B   |     |     |     |     |     |
| NEXT数组 | -1  | 0   | 0   | 1   |     |     |     |     |     |

1. 顺利匹配

|        |     |     | ⬇   |     |     |     |     |     |     |
| ------ | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| index  | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   |     |
| 主串     | A   | B   | C   | A   | B   | A   | B   | C   |     |
|        |     |     | ⬇   |     |     |     |     |     |     |
| index  | 0   | 1   | 2   | 3   |     |     |     |     |     |
| 目标串    | A   | B   | A   | B   |     |     |     |     |     |
| NEXT数组 | -1  | 0   | 0   | 1   |     |     |     |     |     |

2. 不匹配后跳转

|        |     |     | ⬇   |     |     |     |     |     |     |
| ------ | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| index  | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   |     |
| 主串     | A   | B   | C   | A   | B   | A   | B   | C   |     |
|        |     |     | ⬇   |     |     |     |     |     |     |
| index  |     |     | 0   | 1   | 2   | 3   |     |     |     |
| 目标串    |     |     | A   | B   | A   | B   |     |     |     |
| NEXT数组 |     |     | -1  | 0   | 0   | 1   |     |     |     |

|        |     |     |     | ⬇   |     |     |     |     |     |
| ------ | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| index  | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   |     |
| 主串     | A   | B   | C   | A   | B   | A   | B   | C   |     |
|        |     |     |     | ⬇   |     |     |     |     |     |
| index  |     |     |     | 0   | 1   | 2   | 3   |     |     |
| 目标串    |     |     |     | A   | B   | A   | B   |     |     |
| NEXT数组 |     |     |     | -1  | 0   | 0   | 1   |     |     |

3. 匹配成功

|        |     |     |     |     |     |     | ⬇   |     |     |
| ------ | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| index  | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   |     |
| 主串     | A   | B   | C   | A   | B   | A   | B   | C   |     |
|        |     |     |     |     |     |     | ⬇   |     |     |
| index  |     |     |     | 0   | 1   | 2   | 3   |     |     |
| 目标串    |     |     |     | A   | B   | A   | B   |     |     |
| NEXT数组 |     |     |     | -1  | 0   | 0   | 1   |     |     |
